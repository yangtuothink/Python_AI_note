基于epoll方法的IO多路复用

    使用方法 ： 基本与poll相同
        * 生成对象改为 epoll()
		* 将所有事件类型改为EPOLL类型

    epoll特点：
	    * epoll 效率比select poll要高
		* epoll 监控IO数量比select poll要多
        * epoll 的触发方式比poll要多 （EPOLLET 边缘触发, poll 是没有此方法的）
    原理:
        select 和 poll 都是讲所有的 IO 先交给 内核
            如果内核 中触发了IO就绪, 就会将所有的 IO 队列返回给 应用
            应用自己也不知道是哪个就绪, 因此需要一个一个遍历查找,效率较低
        epoll 将 IO 队列存在在内核的时候,
            会申请内核来开辟一定的内存空间来存放这些 IO,
            不会每次都是全部提交, 有新 IO 的时候只需要添加新 IO 即可

            内核发现 队列中 IO 就绪了, 会告诉应用, 应用就会准确的拿到那个就绪的来处理
            不在需要遍历一次了

            虽然效率提升了. 但是也消耗了内存的一定工作能力

        数量上的直观差距
            select 和 poll 最多 1024 个
            epoll 只要内存足够,理论上是可以一直向内核申请开辟内存